package internal

import (
	"fmt"
	"github.com/couchbase/gocb/v2"
	"sync"
	"math/rand"
	"time"
)


func CrudOperations_a(startIndex int, endIndex int, upsertPercent float64, encodedVectors []string, vectors [][]float32,
	xattrFlag bool, base64Flag bool, documentIdPrefix string, provideDefaultDocs bool, collection *gocb.Collection, batchSize int){
	
	source := rand.NewSource(time.Now().UnixNano())
	rand := rand.New(source)

	totalItems := endIndex - startIndex
	numItems := int(float64(totalItems) * upsertPercent)
	
	selectedIndices := rand.Perm(totalItems)[:numItems]
	
	fmt.Printf("CRUD Operation : [Mode : Upsert] : Percentage : %v.\n",upsertPercent)

	for batchStart := 0; batchStart < numItems; batchStart += batchSize {
		batchEnd := batchStart + batchSize
		if batchEnd > numItems {
			batchEnd = numItems
		}

		var wg sync.WaitGroup
		wg.Add(batchEnd - batchStart)
		for _, offset := range selectedIndices[batchStart:batchEnd] {
			j := startIndex + offset
			if xattrFlag {
				if base64Flag {
					vectArr := encodedVectors[j % len(encodedVectors)]
					go UpdateDocumentsXattrbase64(&wg, collection, fmt.Sprintf("%s%d", documentIdPrefix, j+1), vectArr, provideDefaultDocs, j+1)
				} else {
					vectArr := vectors[j % len(vectors)]
					go UpdateDocumentsXattr(&wg, collection, fmt.Sprintf("%s%d", documentIdPrefix, j+1), vectArr, provideDefaultDocs, j+1)
				}
			} else {
				if base64Flag {
					vectArr := encodedVectors[j % len(encodedVectors)]
					go UpdateDocumentsXattrbase64field(&wg, collection, fmt.Sprintf("%s%d", documentIdPrefix, j+1), vectArr, provideDefaultDocs, j+1)
				} else {
					vectArr := vectors[j % len(vectors)]
					go UpdateDocumentsField(&wg, collection, fmt.Sprintf("%s%d", documentIdPrefix, j+1), vectArr, provideDefaultDocs, j+1)
				}
			}
		}
		wg.Wait()
	}
    
	fmt.Printf("CRUD Operation : [Mode : Upsert] : Done.\n")
	fmt.Printf("\n-------------------------------------------------------\n")
	fmt.Printf("CRUD Operation : [Mode : Delete] : Percentage : %v.\n",1 - upsertPercent)
	

	numItems = int(float64(totalItems) * float64(1 - upsertPercent))
	selectedIndices = rand.Perm(totalItems)

	successfulDeletes := 0
	attempts := 0
	batchCount := (numItems + batchSize - 1) / batchSize

	for batchIndex := 0; batchIndex < batchCount && successfulDeletes < numItems; batchIndex++ {
		batchStart := batchIndex * batchSize
		batchEnd := (batchIndex + 1) * batchSize
		if batchEnd > numItems {
			batchEnd = numItems
		}

		var wg sync.WaitGroup
		wg.Add(batchEnd - batchStart)
		for _, offset := range selectedIndices[batchStart:batchEnd] {
			j := startIndex + offset

			go func(index int) {
				defer wg.Done()
				_, err := collection.Remove(fmt.Sprintf("%s%d", documentIdPrefix, j+1), &gocb.RemoveOptions{})
				if err == nil {
					successfulDeletes++
				}
				attempts++
			}(j)
		
		}
		wg.Wait()
	}
	
	fmt.Printf("No of documents deleted: %v\n", successfulDeletes)
	fmt.Printf("No of delete attempts: %v\n", attempts)


	fmt.Printf("CRUD Operation : [Mode : Delete] : Done.\n")
}














// package internal

// import (
// 	"fmt"
// 	"math/rand"
// 	"sync"
// 	"sync/atomic"
// 	"time"

// 	"github.com/couchbase/gocb/v2"
// )

// func CrudOperations(startIndex int, endIndex int, upsertPercent float64, encodedVectors []string, vectors [][]float32,
// 	xattrFlag bool, base64Flag bool, documentIdPrefix string, provideDefaultDocs bool, collection *gocb.Collection, batchSize int) {

// 	source := rand.NewSource(time.Now().UnixNano())
// 	rnd := rand.New(source)

// 	totalItems := endIndex - startIndex
// 	numUpserts := int(float64(totalItems) * upsertPercent)
// 	numDeletes := totalItems - numUpserts

// 	var upsertCount int32
// 	var deleteCount int32
// 	var attempts int32

// 	selectedIndices := rnd.Perm(totalItems)

// 	for batchStart := 0; batchStart < totalItems; batchStart += batchSize {
// 		batchEnd := batchStart + batchSize
// 		if batchEnd > totalItems {
// 			batchEnd = totalItems
// 		}

// 		var wg sync.WaitGroup

// 		for _, offset := range selectedIndices[batchStart:batchEnd] {
// 			if atomic.LoadInt32(&upsertCount) >= int32(numUpserts) && atomic.LoadInt32(&deleteCount) >= int32(numDeletes) {
// 				break
// 			}

// 			j := startIndex + offset

// 			wg.Add(1)
// 			go func(index int) {
// 				// defer wg.Done()
// 				if atomic.LoadInt32(&upsertCount) < int32(numUpserts) && (atomic.LoadInt32(&deleteCount) >= int32(numDeletes) || rnd.Float64() < upsertPercent) {
// 					if xattrFlag {
// 						if base64Flag {
// 							vectArr := encodedVectors[index%len(encodedVectors)]
// 							UpdateDocumentsXattrbase64(&wg, collection, fmt.Sprintf("%s%d", documentIdPrefix, index+1), vectArr, provideDefaultDocs, index+1)
// 						} else {
// 							vectArr := vectors[index%len(vectors)]
// 							UpdateDocumentsXattr(&wg, collection, fmt.Sprintf("%s%d", documentIdPrefix, index+1), vectArr, provideDefaultDocs, index+1)
// 						}
// 					} else {
// 						if base64Flag {
// 							vectArr := encodedVectors[index%len(encodedVectors)]
// 							UpdateDocumentsXattrbase64field(&wg, collection, fmt.Sprintf("%s%d", documentIdPrefix, index+1), vectArr, provideDefaultDocs, index+1)
// 						} else {
// 							vectArr := vectors[index%len(vectors)]
// 							UpdateDocumentsField(&wg, collection, fmt.Sprintf("%s%d", documentIdPrefix, index+1), vectArr, provideDefaultDocs, index+1)
// 						}
// 					}
// 					atomic.AddInt32(&upsertCount, 1)
// 				} else {
// 					_, err := collection.Remove(fmt.Sprintf("%s%d", documentIdPrefix, index+1), &gocb.RemoveOptions{})
// 					if err == nil {
// 						atomic.AddInt32(&deleteCount, 1)
// 						fmt.Printf("Document ID %v got deleted.\n", fmt.Sprintf("%s%d", documentIdPrefix, index+1))
// 					}
// 				}
// 				atomic.AddInt32(&attempts, 1)
// 			}(j)
// 		}

// 		wg.Wait()
// 	}

// 	fmt.Printf("CRUD Operation: [Upserts]: %d\n", upsertCount)
// 	fmt.Printf("CRUD Operation: [Deletes]: %d\n", deleteCount)
// 	fmt.Printf("Total attempts: %d\n", attempts)
// }
